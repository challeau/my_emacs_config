/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   conv_fcts.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: challeau <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/03/11 01:42:38 by challeau          #+#    #+#             */
/*   Updated: 2020/03/11 01:42:48 by challeau         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "tools.h"

int	c_conv(va_list args, t_flags flg, char **buff, int *c_count)
{
    char	*arg;

    if (!(arg = (char *)malloc(2)))
	return (0);
    ft_strncpy(arg, ft_char_to_str((char)va_arg(args, int)), 2);
    if (flg.width > 2)
	arg = ft_add_spaces(arg, flg.width - 1, flg.align);
    if (ft_fill_buff(buff, arg, c_count) == 0)
	return (0);
    return (1);
}

int	s_conv(va_list args, t_flags flg, char **buff, int *c_count)
{
    int		len;
    char	*arg;
    char	*tmp;

    tmp = va_arg(args, char *);
    if (tmp == NULL)
	tmp = "(null)";
    len = ft_strlen(tmp);
    if (!(arg = (char *)malloc(len)))
	return  (0);
    ft_strncpy(arg, tmp, len);
    if (flg.prec >= 0 && flg.prec < len)
	arg[flg.prec] = '\0';
    if ((len = ft_strlen(arg)) < flg.width)
	arg = ft_add_spaces(arg, flg.width - len, flg.align);
    if (ft_fill_buff(buff, arg, c_count) == 0)
	return (0);
    ft_memdel(arg);
    return (1);
}

int		p_conv(va_list args, t_flags flg, char **buff, int *c_count)
{
    void			*tmp;
    unsigned int	num;
    char			*new;

    tmp = va_arg(args, void *);
    num = *(unsigned int*)tmp;
    new = ft_dec_to_base(false, num, 16);
    new += *c_count;
    if (flg.prec == 1)
	*buff = new;
    return (*c_count);
}

int	d_conv(va_list args, t_flags flg, char **buff, int *c_count)
{
    int		i_tmp;
    int		len;
    char	*arg;

    i_tmp = va_arg(args, int);
    if (!(arg = ft_itoa(i_tmp)))
	return (0);
    len = ft_strlen(arg);
    if (flg.align == 2)
	arg = ft_add_zeros(arg, flg.width - len);
    else if (flg.prec > len)
	arg = ft_add_zeros(arg, flg.prec - len);
    if (flg.prec == 0 && ft_strcmp(arg, "0") == 0)
	arg[0] = '\0';
    if (flg.width > 0 && (len = ft_strlen(arg)) < flg.width)
	arg = ft_add_spaces(arg, flg.width - len, flg.align);
    if (ft_fill_buff(buff, arg, c_count) == 0)
	return (0);
    ft_memdel(arg);
    return (1);
}

int	i_conv(va_list args, t_flags flg, char **buff, int *c_count)
{
    int		i_tmp;
    int		len;
    char	*arg;

    i_tmp = va_arg(args, int);
    if (!(arg = ft_itoa(i_tmp)))
	return (0);
    len = ft_strlen(arg);
    if (flg.align == 2)
	arg = ft_add_zeros(arg, flg.width - len);
    else if (flg.prec > len)
	arg = ft_add_zeros(arg, flg.prec - len);
    if (flg.prec == 0 && ft_strcmp(arg, "0") == 0)
	arg[0] = '\0';
    if (flg.width > 0 && (len = ft_strlen(arg)) < flg.width)
	arg = ft_add_spaces(arg, flg.width - len, flg.align);
    if (ft_fill_buff(buff, arg, c_count) == 0)
	return (0);
    ft_memdel(arg);
    return (1);
}

int	u_conv(va_list args, t_flags flg, char **buff, int *c_count)
{
    int			len;
    int			i_tmp;
    unsigned int	u_num;
    char		*arg;

    i_tmp = va_arg(args, int);
    u_num = i_tmp < 0 ? (UINT_MAX + 1) + i_tmp : (unsigned int)i_tmp;
    if (!(arg = ft_utoa(u_num)))
	return (0);
    len = ft_strlen(arg);
    if (flg.align == 2)
	arg = ft_add_zeros(arg, flg.width - len);
    else if (flg.prec > len)
	arg = ft_add_zeros(arg, flg.prec - len);
    if (flg.width > 0 && (len = ft_strlen(arg)) < flg.width)
	arg = ft_add_spaces(arg, flg.width - len, flg.align);
    if (ft_fill_buff(buff, arg, c_count) == 0)
	return (0);
    ft_memdel(arg);
    return (1);
}

int	x_conv(va_list args, t_flags flg, char **buff, int *c_count)
{
    int			len;
    int			i_tmp;
    unsigned int	u_num;
    char		*arg;

    i_tmp = va_arg(args, int);
    u_num = i_tmp < 0 ? (UINT_MAX + 1) + i_tmp : (unsigned int)i_tmp;
    if (!(arg = ft_dec_to_base(false, u_num, 16)))
	return (0);
    len = ft_strlen(arg);
    if (flg.align == 2)
	arg = ft_add_zeros(arg, flg.width - len);
    else if (flg.prec > len)
	arg = ft_add_zeros(arg, flg.prec - len);
    if (flg.width > 0 && (len = ft_strlen(arg)) < flg.width)
	arg = ft_add_spaces(arg, flg.width - len, flg.align);
    if (ft_fill_buff(buff, arg, c_count) == 0)
	return (0);
    ft_memdel(arg);
    return (1);
}

int	X_conv(va_list args, t_flags flg, char **buff, int *c_count)
{
    int			len;
    int			i_tmp;
    unsigned int	u_num;
    char		*arg;

    i_tmp = va_arg(args, int);
    u_num = i_tmp < 0 ? (UINT_MAX + 1) + i_tmp : (unsigned int)i_tmp;
    if (!(arg = ft_dec_to_base(true, u_num, 16)))
	return (0);
    len = ft_strlen(arg);
    if (flg.align == 2)
	arg = ft_add_zeros(arg, flg.width - len);
    else if (flg.prec > len)
	arg = ft_add_zeros(arg, flg.prec - len);
    if (flg.width > 0 && (len = ft_strlen(arg)) < flg.width)
	arg = ft_add_spaces(arg, flg.width - len, flg.align);
    if (ft_fill_buff(buff, arg, c_count) == 0)
	return (0);
    ft_memdel(arg);
    return (1);
}
