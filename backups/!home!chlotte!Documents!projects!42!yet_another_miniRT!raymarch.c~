#include "minirt.h"

t_vec3f	normalize_screen_coordinates(t_vec2f pixel, t_scene scene){
	t_vec3f	uv;

	uv = (t_vec3f){(pixel.x - 0.5 * scene.window_res.x) / scene.window_res.y,
		      -((pixel.y - 0.5 * scene.window_res.y) / scene.window_res.y), 1};
	return (uv);
}

t_rgb	float_to_rgb(float value){
	float r;
	float g;
	float b;

	r = value;
	g = ft_fmod(value * 256, 1.0);
	r -= g / 256;
	b = ft_fmod(value * 256 * 256, 1.0);
	g -= b / 256;
	return ((t_vec3f){r, g, b});
}

float	ft_get_min_dist(float *obj_dists){
	uint8_t	i;
	float	min_dist;

	i = 0;
	min_dist = obj_dists[i];
	while (obj_dists[++i] && i < 20){
		if (obj_dists[i] < min_dist){
			min_dist = obj_dists[i];
		}
	}
	return (min_dist);
}

float	get_dist(t_vec3f pos, t_scene scene)
{
	uint8_t		i;
	float		obj_dists[20] = (float [20]){[0 ... 19] = 0};
	float		(*sdf[__OBJ_TOTAL])(t_vec3f pos, t_object obj) = {sdf_sphere, sdf_plane};

	i = 0;
	while (scene.object_list[i].type != e_OBJ_NONE){
		obj_dists[i] = sdf[scene.object_list[i].type](pos, scene.object_list[i]);
		i++;
	}
	return (ft_get_min_dist(obj_dists));
}

float	raymarch(t_scene scene)
{
	size_t	steps;
	float	dist_origin;
	float	dist_scene;
	t_vec3f	pos;

	steps = 0;
	dist_origin = 0.0;
	while (steps <= MAX_STEPS){
		pos = vec_add(scene.cam_list[0].orientation,
			    vec_scal_mult(scene.cam_list[0].dir, dist_origin)); // marching
		dist_scene = get_dist(pos, scene);
		dist_origin += dist_scene;
		if (dist_origin > MAX_DIST || dist_scene < SURF_DIST)
			break ;
		steps++;
	}
	return (dist_origin);
}

t_rgb	get_pixel_color(t_vec2f pixel, t_scene scene)
{
	t_vec3f	uv;
	float	dist_obj;
	t_rgb	pixel_color;

	uv = normalize_screen_coordinates(pixel, scene);
	scene.cam_list[0].dir = vec_normalize(uv, (t_vec3f){0.0, 0.0, 0.0});
	dist_obj = raymarch(scene);
	if (dist_obj < MAX_DIST)
		pixel_color = (t_rgb){75, 0, 130};
	else
		pixel_color = (t_rgb){255, 239, 213};
	return (pixel_color);
}
