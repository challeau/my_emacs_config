#include "../inc/minirt.h"

bool	ft_setup(t_mlx_obj *mlx, t_mlx_img *img, t_vec2i res, t_vec2f *pixel)
{
	mlx->win_ptr = mlx_new_window(mlx->mlx_ptr, res.x, res.y, "miniRT");
	img->img_ptr = mlx_new_image(mlx->mlx_ptr, res.x, res.y);
	if (mlx->win_ptr == NULL || img->img_ptr == NULL)
		return (false);
	*pixel = (t_vec2f){0.0, 0.0};
	return (true);
}

t_rgb	get_pixel_color(t_vec2f pixel, t_object *obj_list, t_cam cam, t_vec2i res)
{
	t_vec3f		uv;
	t_rgb		color = {0, 0, 0};
	float		dist;
	uint8_t		hit_obj;
	t_vec3f		surf_point;

	uv = normalize_screen_coordinates(pixel, res);
	cam.dir = vec_normalize((t_vec3f){uv.x, uv.y, 1});
	dist = raymarch(cam, obj_list, &hit_obj);
	if (dist <= MAX_DIST)
	{
		surf_point = vec_add(cam.pos, vec_scal_mult(cam.dir, dist));
		color = vec_scal_mult(obj_list[hit_obj].color, get_light(surf_point, obj_list));
	}
	else
		color = (t_rgb){255, 240, 245};
	return (color);
}

void	gamma_correction(t_rgb *color)
{
	color->x = 255 * pow((color->x / 255), 1/2.2);
	color->y = 255 * pow((color->y / 255), 1/2.2);
	color->z = 255 * pow((color->z / 255), 1/2.2);
}

int	main(__attribute__((unused))int ac, __attribute__((unused))char **av)
{
	t_vec2f		pixel;
	t_rgb		pixel_color;
	t_scene		s;	
	t_mlx_obj	mlx;
	t_mlx_img	img;

	mlx.mlx_ptr = mlx_init();
	scene_parser(ac, av, &s, mlx.mlx_ptr);
	if (!ft_setup(&mlx, &img, s.win_res, &pixel))
		return (ft_error(6));
	printf("setup ok\n");
	while (pixel.y <= s.win_res.y)
	{
		while (pixel.x <= s.win_res.x)
		{
			pixel_color = get_pixel_color(pixel, s.obj_list,
						      s.cam_list[0], s.win_res);
			gamma_correction(&pixel_color);
			write_to_image(pixel_color, pixel, &img);
			pixel.x++;
		}
		pixel.x = 0;
		pixel.y++;
	}
	free(s.obj_list);
	free(s.cam_list);
	mlx_put_image_to_window(mlx.mlx_ptr, mlx.win_ptr, img.img_ptr, 0, 0);
	printf("main loop exited. congrats\n");
	mlx_key_hook(mlx.win_ptr, ft_exit, &mlx);
	mlx_loop(mlx.mlx_ptr);
	return (0);
}
