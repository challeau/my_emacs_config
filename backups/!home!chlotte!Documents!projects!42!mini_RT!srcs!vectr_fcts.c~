#include "minirt.h"

float	vec_magnitude(t_vec3 p1, t_vec3 p2){
	float	x;
	float	y;
	float	z;
	float	dist;	

	x = (p2.x - p1.x) * (p2.x - p1.x);
	y = (p2.y - p1.y) * (p2.y - p1.y);
	z = (p2.z - p1.z) * (p2.z - p1.z);
	dist = sqrt(x + y + z);
	return (dist);
}

t_vec3	vec_normalize(t_vec3 uv){
	t_vec3	norm_uv;
	int	vec_len;

	vec_len = vec_magnitude((t_vec3){0,0,0}, uv);
	norm_uv.x = uv.x / vec_len;
	norm_uv.y = uv.y / vec_len;
	norm_uv.z = uv.z / vec_len;
	return (norm_uv);
}

float	vec_dot(t_vec3 v1, t_vec3 v2){	
	float	 product;

	product = (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);
	return (product);
}

t_vec3	vec_add(t_vec3 v1, t_vec3 v2){
	return ((t_vec3){v1.x + v2.x, v1.y + v2.y, v1.z + v2.z});
}

t_vec3	vec_sub(t_vec3 v1, t_vec3 v2){
	return ((t_vec3){v1.x - v2.x, v1.y - v2.y, v1.z - v2.z});
}


// SCALAR OPs
t_vec3	vec_scal_add(t_vec3 uv, float scalar){
	return ((t_vec3){uv.x + scalar, uv.y + scalar, uv.z + scalar});
}

t_vec3	vec_scal_sub(t_vec3 uv, float scalar){
	return ((t_vec3){uv.x - scalar, uv.y - scalar, uv.z - scalar});
}

t_vec3	vec_scal_mult(t_vec3 uv, float scalar){
	return((t_vec3){uv.x * scalar, uv.y * scalar, uv.z * scalar});
}

t_vec3	vec_scal_div(t_vec3 uv, float scalar){
	return((t_vec3){uv.x / scalar, uv.y / scalar, uv.z / scalar});
}
