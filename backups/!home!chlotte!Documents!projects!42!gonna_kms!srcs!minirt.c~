#include "../inc/minirt.h"

bool	ft_setup(t_mlx_obj *mlx, t_mlx_img *img, t_vec2i res, t_vec2f *pixel)
{
	mlx->win_ptr = mlx_new_window(mlx->mlx_ptr, res.x, res.y, "miniRT");
	img->img_ptr = mlx_new_image(mlx->mlx_ptr, res.x, res.y);
	if (mlx->win_ptr == NULL || img->img_ptr == NULL)
		return (false);
	*pixel = (t_vec2f){0.0, 0.0};
	return (true);
}

t_rgb	get_pixel_color(t_vec2f pixel, t_scene scene)
{
	t_vec3f		uv;
	t_rgb		color = {0, 0, 0};
	float		dist;
	uint8_t		hit_obj;
	t_vec3f		surf_point;

	uv = normalize_screen_coordinates(pixel, scene.win_res);
	scene.cam_list[0].dir = vec_normalize((t_vec3f){uv.x, uv.y, 1});
	dist = raymarch(scene.cam_list[0], scene.obj_list, &hit_obj);
	if (dist <= MAX_DIST)
	{
		surf_point = vec_add(scene.cam_list[0].pos, vec_scal_mult(scene.cam_list[0].dir, dist));
		color = vec_scal_mult(scene.obj_list[hit_obj].color, get_light(surf_point, scene.obj_list));
	}
	else
		color = (t_rgb){255, 240, 245};
	free(scene.obj_list);
	return (color);
}

void	gamma_correction(t_rgb *color)
{
	color->x = 255 * pow((color->x / 255), 1/2.2);
	color->y = 255 * pow((color->y / 255), 1/2.2);
	color->z = 255 * pow((color->z / 255), 1/2.2);
}

int	main(int ac, char **av)
{
	t_vec2f		pixel;
	t_rgb		pixel_color;
	t_scene		scene;	
	t_mlx_obj	mlx;
	t_mlx_img	img;

	mlx.mlx_ptr = mlx_init();
	scene_parser(ac, av, &scene, mlx.mlx_ptr);
	if (!ft_setup(&mlx, &img, scene.win_res, &pixel))
		return (ft_error(6));
	while (pixel.y <= scene.win_res.y)
	{
		while (pixel.x <= scene.win_res.y)
		{
			pixel_color = get_pixel_color(pixel, scene);
			gamma_correction(&pixel_color);
			write_to_image(pixel_color, pixel, scene.win_res, &img);
			pixel.x++;
		}
		pixel.x = 0;
		pixel.y++;
	}
	mlx_put_image_to_window(mlx.mlx_ptr, mlx.win_ptr, img.img_ptr, 0, 0);
	printf("main loop exited. congrats\n");
	mlx_key_hook(mlx.win_ptr, ft_exit, &mlx);
	mlx_loop(mlx.mlx_ptr);
	return (0);
}

/* float	get_dist(t_vec3f p, t_object *list) */
/* { */
/* 	float	(*sdfs[__OBJ_TOTAL])(t_vec3f pos, t_object obj) = {sdf_sphere, sdf_plane}; */
/* 	float	obj_dists[20] = (float[20]){[0 ... 19] = 0.0}; */

/* 	for (int i = 0 ; list[i].type != e_OBJ_NONE ; i++) */
/* 		obj_dists[i] = sdfs[list[i].type](p, list[i]); */
/* 	return (ft_min_dist(obj_dists)); */
/* } */

/* t_vec3f	get_normal(t_vec3f p, t_object *list){ */
/* 	float	dist; */
/* 	t_vec3f	eps; */
/* 	t_vec3f	n; */

/* 	dist = get_dist(p, list); */
/* 	eps = (t_vec3f){0.01, 0, 0}; */
/* 	n = (t_vec3f){ */
/* 		get_dist(vec_sub(p, (t_vec3f){eps.x, eps.y, eps.y}), list), */
/* 		get_dist(vec_sub(p, (t_vec3f){eps.y, eps.x, eps.y}), list), */
/* 		get_dist(vec_sub(p, (t_vec3f){eps.y, eps.y, eps.x}), list), */
/* 	}; */
/* 	n = (t_vec3f){dist - n.x, dist - n.y, dist - n.z}; */
/* 	n = vec_normalize(n); */
/* 	return (n); */
/* } */

/* float	get_light(t_vec3f p, t_object *list){ */
/* 	t_vec3f	light_pos; */
/* 	t_vec3f	v_light; */
/* 	t_vec3f	n; */
/* 	float	diff; */

/* 	light_pos = (t_vec3f){0, 1, 0}; */
/* 	v_light = vec_normalize(vec_sub(light_pos, p)); */
/* 	n = get_normal(p, list); */
/* 	diff = ft_fclamp(vec_dot(n, v_light), 0.0, 1.0); */
/* 	if (diff < vec_magnitude(light_pos, p)) */
/* 		diff *= -1; */
/* 	return (diff); */
/* } */

/* float	raymarch(t_cam cam, t_object *list) */
/* { */
/* 	size_t	i; */
/* 	t_vec3f p; */
/* 	float	dist_origin; */
/* 	float	dist_scene; */

/* 	i = 0; */
/* 	dist_origin = 0.0; */
/* 	while (i < MAX_STEPS) */
/* 	{ */
/* 		p = vec_add(cam.pos, vec_scal_mult(cam.dir, dist_origin)); */
/* 		dist_scene = get_dist(p, list); */
/* 		dist_origin += dist_scene; */
/* 		if (dist_origin > MAX_DIST || dist_scene < SURF_DIST) */
/* 			break ; */
/* 		i++; */
/* 	} */
/* 	return (dist_origin); */
/* } */

/* t_rgb	get_pixel_color(t_vec2f pixel, t_scene scene, t_cam cam) */
/* { */
/* 	t_vec3f		uv; */
/* 	t_rgb		color = {0, 0, 0}; */
/* 	float		dist; */
/* 	/\* t_object	*list = (t_object *)malloc(4 * sizeof(t_object)); *\/ */
/* 	/\* for (int i = 0 ; i < 4 ; i++) *\/ */
/* 	/\* 	list[i] = (t_object){.type = e_OBJ_NONE}; *\/ */
/* 	/\* list[0] = (t_object){.type = e_OBJ_SPHERE, *\/ */
/* 	/\* 		     .pos = {0.0, 1, 6}, *\/ */
/* 	/\* 		     .data.sphere.radius = 1}; *\/ */
/* 	/\* list[1] = (t_object){.type = e_OBJ_PLANE, *\/ */
/* 	/\* 		     .pos = {0.7, 0.7, 0.1}, *\/ */
/* 	/\* 		     .data.plane.orientation = {0,0,1}}; *\/ */
/* 	/\* t_cam		cam = (t_cam){.pos = {0, 1, 0}}; *\/ */

/* 	uv = normalize_screen_coordinates(pixel, scene.window_res); */
/* 	cam.dir = vec_normalize((t_vec3f){uv.x, uv.y, 1}); */
/* 	dist = raymarch(cam, scene.obj_list); */
/* 	if (dist <= MAX_DIST) */
/* 	{ */
/* 		color = (t_rgb){135, 206, 250}; */
/* 	} */
/* 	else */
/* 		color = (t_rgb){224, 255, 255}; */
/* 	return (color); */
/* } */

/* int	main(int ac, char **av) */
/* { */
/* 	t_vec2f		pixel = {0, 0}; */
/* 	t_rgb		pixel_color; */
/* 	t_scene		scene; */
/* 	t_mlx_obj	mlx; */
/* 	t_mlx_img	img; */

/* 	mlx.mlx_ptr = mlx_init(); */
/* 	if ((mlx.mlx_ptr = mlx_init()) == NULL) */
/* 		return (0); */
/* 	scene_parser(ac, av, &scene, mlx.mlx_ptr); */
/* 	mlx.win_ptr = mlx_new_window(mlx.mlx_ptr, scene.window_res.x, scene.window_res.y, "miniRT"); */
/* 	img.img_ptr = mlx_new_image(mlx.mlx_ptr, scene.window_res.x, scene.window_res.y); */
/* 	while (pixel.y <= scene.window_res.y) */
/* 	{ */
/* 		while (pixel.x <= scene.window_res.x) */
/* 		{ */
/* 			pixel_color = get_pixel_color(pixel, scene, scene.cam_list[scene.cam_ref]); */
/* 			write_to_image(pixel_color, scene.window_res, &img, pixel); */
/* 			pixel.x++; */
/* 		} */
/* 		pixel.x = 0; */
/* 		pixel.y++; */
/* 	} */
/* 	mlx_put_image_to_window(mlx.mlx_ptr, mlx.win_ptr, img.img_ptr, 0, 0); */
/* 	mlx_key_hook(mlx.win_ptr, ft_exit, &mlx); */
/* 	mlx_loop(mlx.mlx_ptr); */
/* 	return (0); */
/* } */
