#ifndef MINIRT_H
#define MINIRT_H
#include <fcntl.h>
#include <math.h>
#include <mlx.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <X11/Xlib.h>
#include "Libft/libft.h"

#include <assert.h>

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST .01

#define ESC 0xff1b

// VECTORS
typedef struct	s_vec2f {
	float	x;
	float	y;
}		t_vec2f;

typedef struct	s_vec3f {
	float	x;
	float	y;
	float	z;
}		t_vec3f;

typedef struct	s_vec2i {
	int	x;
	int	y;
}		t_vec2i;

typedef struct	s_vec3i {
	int	x;
	int	y;
	int	z;
}		t_vec3i;

typedef struct s_vec3f t_rgb;

// MLX RELATED
typedef struct	s_mlx_obj{
	void	*mlx_ptr;
	void	*win_ptr;		
}		t_mlx_obj;

typedef struct	s_mlx_img{
	void	*img_ptr;
	char	*img_data;
}		t_mlx_img;

// PRE-SETS
typedef struct	s_amb_light {
	float	ratio;
	t_rgb	color;
}		t_amb_light;

typedef struct	s_cam {
	t_vec3f	pos;
	t_vec3f dir;
	uint8_t	fov;
}		t_cam;

//OBJECTS
enum		e_elements {
	e_ELEM_RES,
	e_ELEM_AMBL,
	e_ELEM_CAM,
	e_ELEM_LIGHT,
	e_ELEM_SPHERE,
	e_ELEM_PLANE,
	e_ELEM_SQUARE,
	e_ELEM_CYLINDER,
	e_ELEM_TRIANGLE,
	e_ELEM_CAPSULE,
	__ELEM_TOTAL,
};

enum		e_objects {
		e_OBJ_LIGHT,
		e_OBJ_SPHERE,
		e_OBJ_PLANE,
		e_OBJ_SQUARE,
		e_OBJ_CYLINDER,
		e_OBJ_TRIANGLE,
		e_OBJ_CAPSULE,
		e_OBJ_NONE,
		__OBJ_TOTAL,
};

typedef struct	s_object {
	enum e_objects	type;	// enum_val from id_index
	t_vec3f		pos;
	t_rgb		color;

	union	data {
		struct	light {
			float	ratio;
		}	light;

		struct	sphere {
			float	radius;
		}	sphere;

		struct	plane {
			t_vec3f	orientation;
		}	plane;
		
		struct	square {
			t_vec3f	orientation;
			float	length;
		}	square;
		
		struct	cylinder {
			float	length;
			float	radius;
			t_vec3f	orientation;
		}	cylinder;
		
		struct	triangle {
			t_vec3f	p1;
			t_vec3f	p2;
			t_vec3f	p3;
		}	triangle;

		struct	capsule {
			t_vec3f p1;
			t_vec3f p2;
			float radius;
		}	capsule;
	}	data;
}		t_object;

// SCENE
typedef struct	s_scene {
	t_vec2i		win_res;
	t_amb_light	amb_light;
	t_object	*obj_list;
	t_cam		*cam_list;
	uint8_t		cam_ref;
}		t_scene;

/* PARSER */
bool	parse_scene(int ac, char **av, t_scene *s, void *mlx_ptr);

/* scene elements set fcts */
bool	set_res(char **attributes, t_scene *scene, uint8_t *obj_num);
bool	set_amb_light(char **attributes, t_scene *scene, uint8_t *obj_num);
bool	set_cam(char **attributes, t_scene *scene, uint8_t *obj_num);
bool	set_light(char **attributes, t_scene *scene, uint8_t *obj_num);
bool	set_sphere(char **attributes, t_scene *scene, uint8_t *obj_num);
bool	set_plane(char **attributes, t_scene *scene, uint8_t *obj_num);
bool	set_square(char **attributes, t_scene *scene, uint8_t *obj_num);
bool	set_cylinder(char **attributes, t_scene *scene, uint8_t *obj_num);
bool	set_triangle(char **attributes, t_scene *scene, uint8_t *obj_num);
bool	set_capsule(char **attributes, t_scene *scene, uint8_t *obj_num);

/* parser tools */
bool	check_attributes_num(char **attributes, uint8_t expected);
int	ft_compare_strs(const char *str1, const char *str2);
bool	get_elem_color(char *attributes, t_vec3f *pos);
bool	get_elem_orientation(char *attributes, t_vec3f *pos);
bool	get_elem_position(char *attributes, t_vec3f *pos);


#endif
