#include "../../inc/minirt.h"
#include <mlx.h>
#include <X11/Xlib.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>

float	vec_magnitude(t_vec3f p1, t_vec3f p2){
	float	x;
	float	y;
	float	z;
	float	dist;	

	x = (p2.x - p1.x) * (p2.x - p1.x);
	y = (p2.y - p1.y) * (p2.y - p1.y);
	z = (p2.z - p1.z) * (p2.z - p1.z);
	dist = sqrt(x + y + z);
	return (dist);
}

t_vec3f	vec_normalize(t_vec3f uv, t_vec3f origin){
	t_vec3f	norm_uv;
	int	vec_len;

	vec_len = vec_magnitude(origin, uv);
	norm_uv.x = uv.x / vec_len;
	norm_uv.y = uv.y / vec_len;
	norm_uv.z = uv.z / vec_len;
	return (norm_uv);
}

float	vec_dot(t_vec3f v1, t_vec3f v2){	
	float	 product;

	product = (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);
	return (product);
}

t_vec3f	vec_add(t_vec3f v1, t_vec3f v2){
	return ((t_vec3f){v1.x + v2.x, v1.y + v2.y, v1.z + v2.z});
}

t_vec3f	vec_sub(t_vec3f v1, t_vec3f v2){
	return ((t_vec3f){v1.x - v2.x, v1.y - v2.y, v1.z - v2.z});
}


// SCALAR OPs
t_vec3f	vec_scal_add(t_vec3f uv, float scalar){
	return ((t_vec3f){uv.x + scalar, uv.y + scalar, uv.z + scalar});
}

t_vec3f	vec_scal_sub(t_vec3f uv, float scalar){
	return ((t_vec3f){uv.x - scalar, uv.y - scalar, uv.z - scalar});
}

t_vec3f	vec_scal_mult(t_vec3f uv, float scalar){
	return((t_vec3f){uv.x * scalar, uv.y * scalar, uv.z * scalar});
}

t_vec3f	vec_scal_div(t_vec3f uv, float scalar){
	return((t_vec3f){uv.x / scalar, uv.y / scalar, uv.z / scalar});
}
