#include "../inc/minirt.h"

bool	ft_setup(t_mlx_obj *mlx, t_mlx_img *img, t_vec2f *pixel, t_scene scene)
{
	mlx->win_ptr = mlx_new_window(mlx->mlx_ptr, scene.window_res.x, scene.window_res.y, "miniRT");
	img->img_ptr = mlx_new_image(mlx->mlx_ptr, scene.window_res.x, scene.window_res.y);
	if (mlx->win_ptr == NULL)
		return (false);
	*pixel = (t_vec2f){0, 0};

	return (true);
}

t_scene	set_fake_scene(){
	t_scene new;
	t_cam cam = (t_cam){.pos = {0.0,1,0}, .dir = {0,0,0}};
	t_scene_element sp = (t_scene_element){.type = e_ELEM_SPHERE, .pos = {0.0,1,4}, .data.sphere.r = 2.6};
	t_scene_element pl = (t_scene_element){.type = e_ELEM_PLANE, .pos = {0.0,1,0}, .data.plane.orientation= {0,1,0}};

	new.window_res = (t_vec2i){700, 700};
	new.cam_list[0] = cam;
	new.cam_ref = 0;
	new.elem_list[0] = sp;
	new.elem_list[1] = pl;
	new.elem_list[2] = (t_scene_element){.type = e_ELEM_NONE};
	return(new);
}

int	main(int ac, char **av)
{
	t_scene		scene;
	t_vec2f		pixel;
	t_rgb		color;
	t_mlx_obj	mlx;
	t_mlx_img	img;

	(void)ac;
	(void)av;
	mlx.mlx_ptr = mlx_init();
//	if (!parse_scene(ac, av, &scene, mlx)){
//		write(1, "No henny, wrong setup <3\n", 25);
		//ft_exit();
//		return (0);
//	}
	scene = set_fake_scene();
	ft_setup(&mlx, &img, &pixel, scene);
	printf("setup ok\n");
//	for (int i = 0; scene.elem_list[i].type != e_ELEM_NONE ; i++){
//		printf("obj type: %d\n", scene.elem_list[i].type);
//		printf("obj pos: [%f,%f,%f]\n", scene.elem_list[i].pos.x, scene.elem_list[i].pos.y, scene.elem_list[i].pos.z);
//	}
	while (pixel.y <= scene.window_res.y)
	{
		while (pixel.x <= scene.window_res.y)
		{
			color = get_pixel_color(pixel, scene);
			write2image(color, img, pixel, scene);
			pixel.x++;
		}
		pixel.x = 0;
		pixel.y++;
	}
	mlx_put_image_to_window(mlx.mlx_ptr, mlx.win_ptr, img.img_ptr, 0, 0);
	printf("main loop exited. congrats\n");
	mlx_key_hook(mlx.win_ptr, ft_exit, &mlx);
	mlx_loop(mlx.mlx_ptr);
	return (0);
}
