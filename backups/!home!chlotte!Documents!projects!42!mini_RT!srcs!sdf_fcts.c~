#include "minirt.h"

float	sdf_sphere(t_vec3 p, t_object obj){
	float dist;

	dist = vec_magnitude(p, obj.pos) - obj.data.sphere.r;
	return(dist);
}

float	sdf_plane(t_vec3 p, t_object obj){
	float dist;

	dist = vec_dot(p, obj.data.plane.orientation);// + h;
	return (dist);
}

/* float	sdf_square(t_vec3 p, t_object obj){ */
/* 	t_vec3 ba = b - a; */
/* 	t_vec3 pa = p - a; */
/* 	t_vec3 cb = c - b; */
/* 	t_vec3 pb = p - b; */
/* 	t_vec3 dc = d - c; */
/* 	t_vec3 pc = p - c; */
/* 	t_vec3 ad = a - d; */
/* 	t_vec3 pd = p - d; */
/* 	t_vec3 nor = cross( ba, ad ); */

	
/* 	return sqrt( */
/* 		(sign(dot(cross(ba,nor),pa)) + */
/* 		 sign(dot(cross(cb,nor),pb)) + */
/* 		 sign(dot(cross(dc,nor),pc)) + */
/* 		 sign(dot(cross(ad,nor),pd))<3.0) */
/* 		? */
/* 		min( min( min( */
/* 				  dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa), */
/* 				  dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ), */
/* 			  dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ), */
/* 		     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) ) */
/* 		: */
/* 		dot(nor,pa)*dot(nor,pa)/dot2(nor) ); */
/* } */

/* float	sdf_cylinder(t_vec3 p, t_object obj){ */
/* 	t_vec2 d; */

/* 	d = abs(vec2(vec_magnitude(p, obj.pos),p.y)) - vec2(h,r); */
/* 	d = (t_vec2){ft_abs(vec2(length(p.xz),p.y)) - vec2(h,r); */

/* 	return min(max(d.x,d.y),0.0) + length(max(d,0.0)); */
/* } */
