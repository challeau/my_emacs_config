#include "../../inc/minirt.h"
#define DIFF_COLOR (t_rgb){1.0, 1.0, 1.0}

t_vec3f	get_normal(t_vec3f pos, t_scene scene){
	float	dist;
	t_vec3f	eps;
	t_vec3f n;
	t_vec3f ret;

        get_dist(pos, scene, &dist);
	eps = (t_vec3f){0.01, 0, 0};
	n = (t_vec3f){
		dist - get_dist(vec_sub(pos, (t_vec3f){eps.x, eps.y, eps.y}), scene),
		dist - get_dist(vec_sub(pos, (t_vec3f){eps.y, eps.x, eps.y}), scene),
		dist - get_dist(vec_sub(pos, (t_vec3f){eps.y, eps.y, eps.x}), scene)
	};
	return(vec_normalize(n));
}

t_rgb	get_light(t_vec3f p, t_scene scene){
	t_vec3f	light_pos;
	t_rgb	color;
	t_vec3f	v_light;
	t_vec3f	n;
	float	diff;

	light_pos = (t_vec3f){0, 0, 0};
	color = scene.elem_list[scene.elem_hit_index].color;
	v_light = vec_normalize(vec_sub(light_pos, p));
	n = get_normal(p, scene);
	diff = ft_fclamp(vec_dot(n, v_light), 0.0, 1.0);
	if (diff < vec_magnitude(light_pos, p))
		diff *= -1;
	return (vec_scal_mult(color, diff));
}

float	get_dist(t_vec3f p, t_scene scene){
	uint8_t		i;
	float		obj_dists[20] = (float [20]){[0 ... 19] = 0};
	float		(*sdf[__ELEM_TOTAL])(t_vec3f p, t_scene_element object) = {NULL, NULL, NULL, NULL, sdf_sphere, sdf_plane};

	i = 0;
	while (scene.elem_list[i].type != e_ELEM_NONE){
		obj_dists[i] = sdf[scene.elem_list[i].type](p, scene.elem_list[i]);
		i++;
	}
	scene.elem_hit_index = i;
	return (ft_get_min_dist(obj_dists));
}

float	raymarch(t_cam cam, t_scene scene, t_rgb *color){
	uint8_t	i;
	float	dist_o;		//distance from origin
	float	dist_s;		//distance from scene
	t_vec3f	p;

	i = 0;
	dist_o = 0.0;
	while (i < MAX_STEPS){
		if (dist_o > MAX_DIST)
			break ;
		p = vec_add(cam.orientation, vec_scal_mult(cam.dir, dist_o)); // marching
		dist_s = get_dist(p, scene);
		if (dist_s < SURF_DIST){
			*color = scene.elem_list[scene.elem_hit_index].color;
			break ;
		}
		dist_o += dist_s;
		i++;
	}

}

t_rgb	get_pixel_color(t_vec2f pixel, t_scene scene){
	t_vec3f	uv;
	t_rgb	color;
	float	dist_elem;
	t_cam	curr_cam;
	t_vec3f	p;

	uv = normalize_screen_coordinates(pixel, scene);
	curr_cam = scene.cam_list[scene.cam_ref];
	curr_cam.dir = vec_normalize(uv); // gives a unit vector (== size of 1)
	dist_elem = raymarch(curr_cam, scene, &color);
	p = vec_add(curr_cam.orientation, vec_scal_mult(curr_cam.dir, dist_elem)); // marching
	color = get_light(p, scene, DIFF_COLOR);
	return (color);
}
