#ifndef MINIRT_H
#define MINIRT_H
#include <mlx.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <math.h>
#include <stdio.h>
#include "Libft/libft.h"

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST .01

#define ESC 0xff1b

// MLX RELATED
typedef struct	s_mlx_obj{
	void	*mlx_ptr;
	void	*win_ptr;		
}		t_mlx_obj;

typedef struct	s_mlx_img{
	void	*img_ptr;
	char	*img_data;
}		t_mlx_img;

// OBJECTS
typedef struct	s_vec2 {
	float	x;
	float	y;
}		t_vec2;

typedef struct	s_vec3 {
	float	x;
	float	y;
	float	z;
}		t_vec3;

typedef struct	s_amb_light {
	uint8_t	ratio;
	t_vec3	rgb;
}		t_amb_light;

enum objects {
	e_OBJ_RES,
	e_OBJ_AMBL,
	e_OBJ_CAM,
	e_OBJ_LIGHT,
	e_OBJ_SPHERE,
	e_OBJ_PLANE,
	e_OBJ_SQUARE,
	e_OBJ_CYLINDER,
	e_OBJ_TRIANGLE,
	e_OBJ_NONE,
	__OBJ_TOTAL,
};

typedef struct	s_object {
	enum objects	type; // enum_val from id_index
	t_vec3		pos;
	t_vec3		color;

	union	data {
		struct	cam {
			t_vec3	ori;
			t_vec3	dir;
			int	fov;
		}	cam;

		struct	light {
			uint8_t	ratio;
		}	light;

		struct	sphere {
			float	r;
		}	sphere;

		struct	plane {
			t_vec3	orientation;
		}	plane;
		
		struct	square {
			t_vec3	orientation;
			float	l;
		}	square;
		
		struct	cylinder {
			float	l;
			float	r;
			t_vec3	orientation;
		}	cylinder;
		
		struct	triangle {
			t_vec3	p1;
			t_vec3	p2;
			t_vec3	p3;
		}	triangle;

	}	data;
}		t_object;

typedef struct	s_obj_lst{
	t_object	obj;
	struct s_obj_lst	*next;
}		t_obj_lst;

typedef struct	s_scene{
	bool		is_set;
	t_vec2		res;
	t_amb_light	amb_light;
	t_obj_lst	*obj_list;
}		t_scene;

// UTIlITIES idk
t_vec3	get_pixel_color(t_scene scene, t_vec2 pixel);
float	get_light(float dist_obj, t_scene scene);
t_vec3	get_normal(t_vec3 pos, t_scene scene);
t_vec3	float_to_rgb(float value);

// PAARSER
t_scene	parser(int ac, char **av);
t_scene get_scene(int fd);
bool	parse_color(char *attributes, t_vec3 *color);
bool	parse_position(char *attributes, t_vec3 *pos);
bool	parse_orientation(char *attributes, t_vec3 *ori);
bool	check_attributes_num(char **attributes, uint8_t expected);


// SCENE AND OBJ SET
bool	set_res(char **attributes, t_scene *scene);
bool	set_ambl(char **attributes, t_scene *scene);
t_object	set_cam(char **attributes);
t_object	set_light(char **attributes);
t_object	set_sphere(char **attributes);
t_object	set_plane(char **attributes);
t_object	set_square(char **attributes);
t_object	set_cylinder(char **attributes);
t_object	set_triangle(char **attributes);

// PARSER II - OBJ SHIT
t_obj_lst	*new_obj_lst(t_object object);
void	add_obj2lst(t_obj_lst **lst, t_obj_lst *new);

// VECTOR SHIT
float	vec_magnitude(t_vec3 a, t_vec3 b);
t_vec3	vec_normalize(t_vec3 uv);
t_vec3	vec_scal_mult(t_vec3 vec, float scalar);
t_vec3	vec_add(t_vec3 v1, t_vec3 v2);
t_vec3	vec_sub(t_vec3 v1, t_vec3 v2);
float	vec_dot(t_vec3 v1, t_vec3 v2);
t_vec3	vec_scal_add(t_vec3 uv, float scalar);
t_vec3	vec_scal_sub(t_vec3 uv, float scalar);
t_vec3	vec_scal_mult(t_vec3 uv, float scalar);
t_vec3	vec_scal_div(t_vec3 uv, float scalar);

// RAYMARCH STUFF
float	get_dist(t_vec3 p, t_scene scene);
float	raymarch(t_scene scene);

// SDFs
float	sdf_sphere(t_vec3 p, t_object obj);
float	sdf_plane(t_vec3 p, t_object obj);
float	sdf_sqaure(t_vec3 p, t_object obj);
float	sdf_cylinder(t_vec3 p, t_object obj);
float	sdf_triangle(t_vec3 p, t_object obj);

// IMAGE THANGS
void	write2image(t_vec3 color, t_mlx_img img, t_vec2 pixel, t_scene scene);

// KEY TOOLS
int	ft_exit(int keycode, void *param);

// TOOLS
int	ft_abs(int num);
int	ft_floor(float value);
float	ft_mod(float a, float b);

#endif
