#include "../inc/minirt.h"

t_vec3f	normalize_screen_coordinates(t_vec2f pixel, t_vec2i res)
{
	t_vec3f	uv;

	uv = (t_vec3f){(pixel.x - 0.5 * res.x) / res.y,
		      -((pixel.y - 0.5 * res.y) / res.y), 1};
	return (uv);
}

float	sdf_sphere(t_vec3f pos, t_object obj)
{
	float dist;

	dist = vec_magnitude(obj.pos, pos) - obj.data.sphere.radius;
	return(dist);
}

float	sdf_plane(t_vec3f pos, t_object obj)
{
	float dist;

	dist = vec_dot(pos, obj.data.plane.orientation);// + h;
	return (dist);
}

float	ft_min_dist(float *obj_dists, uint8_t *hit_obj)
{
	uint8_t	i;
	float	min_dist;

	i = 0;
	min_dist = MAX_DIST;
	while (obj_dists[i] && i < 20){
		if (obj_dists[i] < min_dist){
			min_dist = obj_dists[i];
			*hit_obj = i;
		}
		i++;
	}
	return (min_dist);
}

float	get_dist(t_vec3f p, t_object *list, uint8_t *hit_obj)
{
	float	(*sdfs[__OBJ_TOTAL])(t_vec3f pos, t_object obj) = {NULL, sdf_sphere, sdf_plane, NULL, NULL, NULL};
	float	obj_dists[20] = (float[20]){[0 ... 19] = 0.0};

	for (int i = 0 ; list[i].type != e_OBJ_NONE ; i++){
		obj_dists[i] = sdfs[list[i].type](p, list[i]);
	}
	return (ft_min_dist(obj_dists, hit_obj));
}

t_vec3f	get_normal(t_vec3f p, t_object *list)
{
	float dist;
	t_vec3f n;
	uint8_t nun;

	dist = get_dist(p, list, &nun);
	n = (t_vec3f){
		get_dist((t_vec3f){p.x + 0.01, p.y, p.z}, list, &nun) - dist,
		get_dist((t_vec3f){p.x, p.y + 0.01, p.z}, list, &nun) - dist,
		get_dist((t_vec3f){p.x, p.y, p.z + 0.01}, list, &nun) - dist,
	};
	return (vec_scal_div(n, 0.01));
}

float	get_light(t_vec3f surf_point, t_object *list)
{
	t_vec3f	light_pos;
	t_vec3f	light_vec;
	t_vec3f	n;
	float	diff;

	light_pos = (t_vec3f){0, 1, 2};
	light_vec = vec_normalize(vec_sub(light_pos, surf_point));
	n = get_normal(surf_point, list);
	diff = vec_dot(n, light_vec);
	diff = ft_fclamp(diff, 0.0, 1.0);
	return (diff);
}

float	raymarch(t_cam cam, t_object *list, uint8_t *hit_obj)
{
	size_t	i;
	t_vec3f p;
	float	dist_origin;
	float	dist_scene;

	i = 0;
	dist_origin = 0.0;
	while (i < MAX_STEPS)
	{
		p = vec_add(cam.pos, vec_scal_mult(cam.dir, dist_origin));
		dist_scene = get_dist(p, list, hit_obj);
		dist_origin += dist_scene;
		if (dist_origin > MAX_DIST || dist_scene < SURF_DIST)
			break ;
		i++;
	}
	return (dist_origin);
}
