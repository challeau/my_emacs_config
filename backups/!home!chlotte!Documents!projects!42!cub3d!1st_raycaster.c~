#include "cub3d.h"

static int curr_map[map_width][map_height] =
{
  {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,2,2,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,3,0,0,0,3,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,2,0,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,0,0,0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};

double	ft_abs(double num)
{
	return(num < 0 ? num * -1 : num);
}

void	ft_init_point(struct s_point *point, double x, double y)
{
	point->x = x;
	point->y = y;
}

int	ft_lol()
{
	int i = 0;
	struct s_mlx_obj	mlx;
	struct s_point	pos;		/* start position */
	struct s_point	dir;		/* initial direction vector */
	struct s_point	plane;		/* camera plane */
	double		time;		/* time of current frame */
	double		old_time;	/* time of prev frame */
	double camerax = 0;		/* x coordinate in camera space */
	struct s_point ray_dir;
	struct s_point map;
	struct s_point side_dist;
	struct s_point delta_dist;
	double perp_wall_dist;
	struct s_point step;
	int hit;
	int side;
	int line_height;
	int draw_start;
	int draw_end;
	uint32_t color;

	time = 0;
	old_time = 0;
	ft_init_point(&pos, 22, 12);
	ft_init_point(&dir, -1, 0);
	ft_init_point(&plane, 0, 0.66);
	ft_init_point(&ray_dir, 0, 0);
	mlx.mlx_ptr = mlx_init();
	mlx.win_ptr = mlx_new_window(mlx.mlx_ptr, screen_width, screen_height, "raycaster");
	while (i < screen_width)
	{
		camerax = 2 * i / (double)screen_width - 1; //x-coordinate in camera space
		ray_dir.x = dir.x + plane.x * camerax;
		ray_dir.y = dir.y + plane.y * camerax;
		ft_init_point(&map, pos.x, pos.y);
		if (ray_dir.y == 0){
			delta_dist.x = 0;
		}
		else if (ray_dir.x == 0)
			delta_dist.x = 1;
		else
			delta_dist.x = ft_abs(1 / ray_dir.x);
		if (ray_dir.x == 0){
			delta_dist.y = 0;
		}
		else if (ray_dir.y == 0)
			delta_dist.y = 1;
		else
			delta_dist.y = ft_abs(1 / ray_dir.y);
      		//calculate step and initial sideDist
		if (ray_dir.x < 0)
		{
			step.x = -1;
			side_dist.x = (pos.x - map.x) * delta_dist.x;
		}
		else
		{
			step.x = 1;
			side_dist.x = (map.x + 1.0 - pos.x) * delta_dist.x;
		}
		if (ray_dir.y < 0)
		{
			step.y = -1;
			side_dist.y = (pos.y - map.y) * delta_dist.y;
		}
		else
		{
			step.y = 1;
			side_dist.y = (map.y + 1.0 - pos.y) * delta_dist.y;
		}
		//perform DDA
		while (hit == 0)
		{
			//jump to next map square, OR in x-direction, OR in y-direction
			if (side_dist.x < side_dist.y)
			{
				side_dist.x += delta_dist.x;
				map.x += step.x;
				side = 0;
			}
			else
			{
				side_dist.y += delta_dist.y;
				map.y += step.y;
				side = 1;
			}
			//Check if ray has hit a wall
			if (curr_map[(int)map.x][(int)map.y] > 0)
				hit = 1;
		}
		//Calculate distance projected on camera direction (Euclidean distance will give fisheye effect!)
		if (side == 0)
			perp_wall_dist = (map.x - pos.x + (1 - step.x) / 2) / ray_dir.x;
		else
			perp_wall_dist = (map.y - pos.y + (1 - step.y) / 2) / ray_dir.y;
		//Calculate height of line to draw on screen
		line_height = (int)(screen_height / perp_wall_dist);
		//calculate lowest and highest pixel to fill in current stripe
		draw_start = -line_height / 2 + screen_height / 2;
		if(draw_start < 0)
			draw_start = 0;
		draw_end = line_height / 2 + screen_height / 2;
		if(draw_end >= screen_height)
			draw_end = screen_height - 1;
		//give x and y sides different brightness
		color = (side == 1) ? 0x00FF00 : 0xFF0000;
		//draw the pixels of the stripe as a vertical line
				
		i++;
	}
	mlx_loop(mlx.mlx_ptr);
	return (0);
}
