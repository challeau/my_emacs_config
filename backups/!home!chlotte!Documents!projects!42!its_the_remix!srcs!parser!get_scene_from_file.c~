#include "../../inc/minirt.h"

/* allocates memory for the list of objects in the scene (limited to 20). */
/* allocates memory for the list of cameras in the scene (limited to 10). */
/* set default values for the ambient light and window resolution to check */
/* later that they have been assigned. */
void	alloc_scene_lists(t_scene *scene)
{
	uint8_t		i;
	t_cam		default_cam;
	t_object	none_obj;

	i = 0;
	scene->win_res = (t_vec2i){0, 0};
	scene->amb_light.ratio = -1;
	default_cam = (t_cam){.pos = {0.0, 1.0, 0.0}, .dir = {0.0, 0.0, 1.0}};
	scene->cam_list = (t_cam *)malloc(10 * sizeof(t_cam));
	while (i < 10)
	{
		scene->cam_list[i] = default_cam;
		i++;
	}
	scene->cam_ref = 0;
	i = 0;
	none_obj = (t_object){.type = e_OBJ_NONE};
	scene->obj_list = (t_object *)malloc(20 * sizeof(t_object));
	while (i < 20)
	{
		scene->obj_list[i] = none_obj;
		i++;
	}
}

/* returns the value of the enum corresponding to the element_type. */
int	id_index(const char *id)
{
	int			i;
        static const char	*elem_id_array[__ELEM_TOTAL] = {
		"R", "A", "c", "l", "sp", "pl", "sq", "cy", "tr", "ca"};

	i = 0;
	while (i < __ELEM_TOTAL){
		if (ft_compare_strs(id, elem_id_array[i]) == 1)
			return (i);
		i++;
	}
	return (-1);
}

/* assigns value to each element in the source file. */
bool	handle_attributes(t_scene *s, char **attributes)
{
	int		enum_val;
	static uint8_t	obj_num = 0;
	static bool		(*obj_set_fcts[__ELEM_TOTAL])
		(char **attributes, t_scene *scene, uint8_t *obj_num);

	enum_val = id_index(attributes[0]);
	obj_set_fcts[0] = &set_res;
	obj_set_fcts[1] = &set_amb_light;
	obj_set_fcts[2] = &set_cam;
	obj_set_fcts[3] = &set_light;
	obj_set_fcts[4] = &set_sphere;
	obj_set_fcts[5] = &set_plane;
	obj_set_fcts[6] = &set_square;
	obj_set_fcts[7] = &set_cylinder;
	obj_set_fcts[8] = &set_triangle;
	obj_set_fcts[9] = &set_capsule;
	if (enum_val != -1)
		return (obj_set_fcts[enum_val](attributes, s, &obj_num));
	return (false);
}

bool	parse_source_file(int fd, t_scene *s)
{
	int	ret;
	char	*line;
	char	**obj_attributes;
	char	**obj_attributes_ptr;

	ret = 1;
	while ((ret = get_next_line(fd, &line)) > 0)
	{
		if (line[0] != '\0')
		{
			obj_attributes = ft_split(line, ' ');
			if (handle_attributes(s, obj_attributes) == false)
				return(false);
			obj_attributes_ptr = obj_attributes;
			while (*obj_attributes_ptr != NULL)
			{
				ft_memdel(*obj_attributes_ptr);
				obj_attributes_ptr++;
			}
		}
		ft_memdel(line);
	}
	if (ret == -1)
		return (false);
	return (true);
}

bool	get_scene_from_file(int ac, char **av, t_scene *s, void *mlx_ptr)
{
	bool	scene_is_set;
	int	fd;

	if (ac == 2 || ac == 3)
	{
		fd = open(av[1], O_RDONLY);
		alloc_scene_lists(s);
		scene_is_set = parse_source_file(fd, s) &
			check_necessary_elements(s, mlx_ptr);
		close(fd);
		if (scene_is_set == false)
			ft_error_parser(*s, true);
		return (true);
	}
	ft_error_parser(*s, false);
	return (false);
}
