#ifndef MINIRT_H
#define MINIRT_H
#include <mlx.h>
#include <X11/Xlib.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <math.h>
#include "Libft/libft.h"
#include <stdio.h>
#include <assert.h>

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST .01

#define ESC 0xff1b

// MLX RELATED
typedef struct	s_mlx_obj{
	void	*mlx_ptr;
	void	*win_ptr;		
}		t_mlx_obj;

typedef struct	s_mlx_img{
	void	*img_ptr;
	char	*img_data;
}		t_mlx_img;

// OBJECTS
typedef struct	s_vec2f {
	float	x;
	float	y;
}		t_vec2f;

typedef struct	s_vec3f {
	float	x;
	float	y;
	float	z;
}		t_vec3f;

typedef struct	s_vec2i {
	int	x;
	int	y;
}		t_vec2i;

typedef struct	s_vec3i {
	int	x;
	int	y;
	int	z;
}		t_vec3i;

typedef struct	s_vec3f t_rgb; 

enum		e_objects {
		e_OBJ_SPHERE,
		e_OBJ_PLANE,
		e_OBJ_SQUARE,
		e_OBJ_CYLINDER,
		e_OBJ_TRIANGLE,
		e_OBJ_NONE,
		__OBJ_TOTAL,
};

typedef struct	s_amb_light {
	float	ratio;
	t_rgb	color;
}		t_amb_light;	

typedef struct	s_cam {
	t_vec3f	pos;
	t_vec3f	orientation;
	t_vec3f	dir;
	int	fov;
}		t_cam;

typedef struct	s_object {
	enum e_objects	type;	// enum_val from id_index
	t_vec3f		pos;
	t_rgb		color;
	union		data {
		struct	sphere {
			float	radius;
		}	sphere;
		struct	plane {
			t_vec3f	orientation;
		}	plane;
		struct	square {
			t_vec3f	orientation;
			float	length;
		}	square;
		struct	cylinder {
			float	lenght;
			float	raduis;
			t_vec3f	orientation;
		}	cylinder;
		struct	triangle {
			t_vec3f	p1;
			t_vec3f	p2;
			t_vec3f	p3;
		}	triangle;
	}	data;
}		t_object;

typedef struct	s_scene{
	t_vec2i		window_res;
	t_amb_light	amb_light;
	t_cam		*cam_list;
	t_object	*object_list;
}		t_scene;

// raymarch stuff
float	raymarch(t_scene scene);
t_rgb	get_pixel_color(t_vec2f pixel, t_scene scene);

// sdfs
float	sdf_sphere(t_vec3f p, t_object obj);
float	sdf_plane(t_vec3f p, t_object obj);

//vector tools
float	vec_magnitude(t_vec3f p1, t_vec3f p2);
t_vec3f	vec_normalize(t_vec3f uv, t_vec3f origin);
float	vec_dot(t_vec3f v1, t_vec3f v2);
t_vec3f	vec_add(t_vec3f v1, t_vec3f v2);
t_vec3f	vec_sub(t_vec3f v1, t_vec3f v2);

// scalar ops
t_vec3f	vec_scal_add(t_vec3f uv, float scalar);
t_vec3f	vec_scal_sub(t_vec3f uv, float scalar);
t_vec3f	vec_scal_mult(t_vec3f uv, float scalar);
t_vec3f	vec_scal_div(t_vec3f uv, float scalar);

// float tools
int	ft_fabs(int num);
int	ft_ffloor(float value);
float	ft_fmod(float x, float y);
float	ft_fclamp(float num, float low_bound, float high_bound);

int	ft_exit(int keycode, void *param);
void	write2image(t_vec3f color, t_mlx_img *img, t_vec2f pixel, t_scene scene);

#endif
