#include "../minirt.h"

float	ft_get_min_dist(float obj_dists[10]){
	size_t	i;
	float	min_dist;

	i = 0;
	min_dist = MAX_DIST;
	while(obj_dists[i]){
		if (obj_dists[i] < min_dist)
			min_dist = obj_dists[i];
		i++;
	}
	return (min_dist);
}

float	get_dist(t_vec3 p, t_scene scene){
	(void)scene;
	t_object	sphere = (t_object){
			.type = e_OBJ_SPHERE,
			.pos  = {0,1,4},
			.color = {255,255,255},
			.data.sphere.r = 1.,
	};
	t_object	plane = (t_object){
		.type = e_OBJ_PLANE,
		.pos = {0,1,0},
		.data.plane.orientation = (t_vec3){0,1,0},
	};
	t_object	none = (t_object){
		.type = e_OBJ_NONE,
	};

	t_object	obj_list[3] = {sphere, plane, none};
	size_t		i;
	float		obj_dists[10] = (float [10]){[0 ... 9] = 0};
	float		(*sdf[5])(t_vec3 p, t_object object) = {sdf_sphere, sdf_plane};

	i = 0;
	while (obj_list[i].type != e_OBJ_NONE){
		obj_dists[i] = sdf[obj_list[i].type](p, obj_list[i]);
		i++;
	}
	return (ft_get_min_dist(obj_dists));
}

float	raymarch(t_scene scene){
	size_t	i;
	float	dist_o;
	float	dist_s;
	t_vec3	p;

	i = 0;
	dist_o = 0.;
	while (i <= MAX_STEPS){
		p = vec_add(scene.cam.ori, vec_scal_mult(scene.cam.dir, dist_o)); // marching
		dist_s = get_dist(p, scene);
		dist_o += dist_s;
		if (dist_o > MAX_DIST || dist_s < SURF_DIST)
			break ;
		i++;
	}
	return (dist_o);
}

t_vec3	normalize_screen_coordinates(t_vec2 pixel, t_scene scene){
	t_vec3	uv;

	uv = (t_vec3){(pixel.x - 0.5 * scene.res.x) / scene.res.y,
		      -((pixel.y - 0.5 * scene.res.y) / scene.res.y), 1};
	return (uv);
}

t_vec3	get_pixel_color(t_scene scene, t_vec2 pixel){
	t_vec3	uv;
	t_vec3	color;
	float	dist_obj;
	
	uv = normalize_screen_coordinates(pixel, scene);
	scene.cam.dir = vec_normalize(uv);	// gives a unit vector (== size of 1)
	dist_obj = raymarch(scene);
	if (dist_obj < MAX_DIST){
		// most of the cool stuff goes here
		color = float_to_rgb(pow(255 * get_light(dist_obj, scene), 1/2.2));
	}
	else {
		// almost nothing goes here lol
		color = (t_vec3){0,0,0};
	}
	return (color);
}
