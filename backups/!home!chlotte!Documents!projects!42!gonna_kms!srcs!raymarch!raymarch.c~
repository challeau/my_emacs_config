#include "../../inc/minirt.h"

float	get_dist(t_vec3f p, t_object *list, uint8_t *hit_obj)
{
	float	(*sdfs[__OBJ_TOTAL])(t_vec3f pos, t_object obj) = {NULL, sdf_sphere, sdf_plane, NULL, NULL, NULL};
	float	obj_dists[20] = (float[20]){[0 ... 19] = 0.0};

	for (int i = 0 ; list[i].type != e_OBJ_NONE ; i++){
		obj_dists[i] = sdfs[list[i].type](p, list[i]);
	}
	return (ft_min_dist(obj_dists, hit_obj));
}

t_vec3f	get_surface_normal(t_vec3f p, t_object *list)
{
	float dist;
	t_vec3f n;
	uint8_t nun;

	dist = get_dist(p, list, &nun);
	n = (t_vec3f){
		get_dist((t_vec3f){p.x + 0.01, p.y, p.z}, list, &nun) - dist,
		get_dist((t_vec3f){p.x, p.y + 0.01, p.z}, list, &nun) - dist,
		get_dist((t_vec3f){p.x, p.y, p.z + 0.01}, list, &nun) - dist,
	};
	return (vec_scal_div(n, 0.01));
}

float	get_light(t_vec3f surf_point, t_object *list)
{
	t_vec3f	light_pos;
	t_vec3f	light_vec;
	t_vec3f	n;
	float	diff;

	light_pos = (t_vec3f){0, 1, 2};
	light_vec = vec_normalize(vec_sub(light_pos, surf_point));
	n = get_surface_normal(surf_point, list);
	diff = vec_dot(n, light_vec);
	diff = ft_fclamp(diff, 0.0, 1.0);
	return (diff);
}

float	raymarch(t_cam cam, t_object *list, uint8_t *hit_obj)
{
	size_t	i;
	t_vec3f p;
	float	dist_origin;
	float	dist_scene;

	i = 0;
	dist_origin = 0.0;
	while (i < MAX_STEPS)
	{
		p = vec_add(cam.pos, vec_scal_mult(cam.dir, dist_origin));
		dist_scene = get_dist(p, list, hit_obj);
		dist_origin += dist_scene;
		if (dist_origin > MAX_DIST || dist_scene < SURF_DIST)
			break ;
		i++;
	}
	return (dist_origin);
}
