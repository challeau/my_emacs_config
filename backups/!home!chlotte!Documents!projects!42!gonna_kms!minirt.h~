#ifndef MINIRT_H
#define MINIRT_H
#include <mlx.h>
#include <X11/Xlib.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>
#include "Libft/libft.h"

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST .01

#define ESC 0xff1b

// MLX RELATED
typedef struct	s_mlx_obj{
	void	*mlx_ptr;
	void	*win_ptr;		
}		t_mlx_obj;

typedef struct	s_mlx_img{
	void	*img_ptr;
	char	*img_data;
}		t_mlx_img;

// OBJECTS
typedef struct	s_vec2f {
	float	x;
	float	y;
}		t_vec2f;

typedef struct	s_vec3f {
	float	x;
	float	y;
	float	z;
}		t_vec3f;

typedef struct	s_vec2i {
	int	x;
	int	y;
}		t_vec2i;

typedef struct	s_vec3i {
	int	x;
	int	y;
	int	z;
}		t_vec3i;

typedef struct s_vec3f t_rgb;

typedef struct	s_cam {
	t_vec3f	pos;
	t_vec3f dir;
}		t_cam;

enum		e_objects {
		e_OBJ_SPHERE,
		e_OBJ_PLANE,
		e_OBJ_NONE,
		__OBJ_TOTAL,
};

typedef struct	s_object {
	enum e_objects	type;	// enum_val from id_index
	t_vec3f		pos;
	t_rgb		color;

	union	data {
		struct	sphere {
			float	radius;
		}	sphere;

		struct	plane {
			t_vec3f	orientation;
		}	plane;

	}	data;
}		t_object;

//vector tools
float	vec_magnitude(t_vec3f p1, t_vec3f p2);
t_vec3f	vec_normalize(t_vec3f uv);
float	vec_dot(t_vec3f v1, t_vec3f v2);
t_vec3f	vec_add(t_vec3f v1, t_vec3f v2);
t_vec3f	vec_sub(t_vec3f v1, t_vec3f v2);
// scalar ops
t_vec3f	vec_scal_add(t_vec3f uv, float scalar);
t_vec3f	vec_scal_sub(t_vec3f uv, float scalar);
t_vec3f	vec_scal_mult(t_vec3f uv, float scalar);
t_vec3f	vec_scal_div(t_vec3f uv, float scalar);
// float tools
int	ft_fabs(int num);
int	ft_ffloor(float value);
float	ft_fmod(float x, float y);
float	ft_fclamp(float num, float low_bound, float high_bound);

#endif
